# 2dEditor 中的 3D 模型渲染功能分析

在 2dEditor 应用中，3dModel 目录包含了用于 3D 模型渲染的组件，主要用于纹理预览和 3D 效果展示。这部分功能使用了两个主要的 3D 渲染库：Three.js 和 Babylon.js。

## 3dModel 目录结构

3dModel 目录包含以下文件：
- BabyLonModelView.tsx
- CustomLoadingScreen.ts
- ObjViewer.tsx
- ObjViewer.module.scss

## 使用场景

这些 3D 渲染组件主要在以下场景中使用：

1. **纹理预览**：当用户在编辑器中添加纹理效果（如浮雕、光泽等）时，可以通过 3D 预览查看效果
2. **产品展示**：将 2D 设计应用到 3D 产品模型上进行预览
3. **旋转体渲染**：对于杯子等旋转体产品，可以将 2D 设计应用到 3D 模型上

从代码中可以看到，纹理预览功能通过 `texturePreviewWrap` 容器展示：

```jsx
<div style={{zIndex: showTextureView ? 3 : 0, opacity: showTextureView ? 1 : 0}} className="texturePreviewWrap">
    <TexturePreview showTextureView={showTextureView} setShowTextureView={setShowTextureView} />
</div>
```

## Three.js 的应用

Three.js 主要用于纹理预览和旋转体渲染，相关实现在 `textureScene.ts` 和 `rotatingBodyScene.ts` 中：

### 1. 纹理场景 (TextureScene)

`TextureScene` 类负责创建和管理用于纹理预览的 3D 场景：

- **初始化场景**：创建相机、场景、灯光、渲染器等
- **创建纹理对象**：将灰度图转换为 3D 网格，应用材质
- **处理旋转体**：对于杯子等旋转体产品，创建特殊的 3D 模型

关键功能：
```typescript
create(textureData: any) {
  // 创建场景和设置相机
  // 加载纹理图像
  // 创建材质和网格
  // 添加到场景
}

createRotating(textureData: any, rotary_params: any) {
  // 创建旋转体模型（如杯子）
  // 应用纹理
}
```

### 2. 旋转体场景 (RotatingBodyScene)

`RotatingBodyScene` 类专门用于创建和渲染旋转体产品（如杯子）：

- **创建圆柱体**：根据参数创建不同尺寸的圆柱体
- **创建圆环**：用于杯口等细节
- **应用纹理**：将设计应用到 3D 模型上

```typescript
create(textureData: any, rotary_params: any) {
  // 创建材质
  // 加载纹理
  // 创建圆柱体和圆环
  // 组合成完整的旋转体模型
}
```

## Babylon.js 的应用

Babylon.js 主要用于加载和渲染更复杂的 3D 模型，实现在 `BabyLonModelView.tsx` 中：

### BabyLonModelView

这个组件用于加载和渲染 3D 模型文件（如 .obj, .glb, .gltf 等）：

- **创建 Babylon 场景**：初始化引擎和场景
- **加载 3D 模型**：支持多种格式的模型文件
- **应用材质和纹理**：将设计应用到模型上
- **交互控制**：支持旋转、缩放等交互

## ObjViewer 组件

`ObjViewer` 组件是基于 Three.js 的 React 组件，用于加载和显示 OBJ 格式的 3D 模型：

```typescript
const ObjModel: React.FC<ObjModelProps> = ({ path, texturePath }) => {
  // 加载 OBJ 或 GLTF 模型
  // 加载纹理
  // 设置材质属性
  // 处理交互（拖拽、缩放等）
}
```

这个组件支持：
- 加载 OBJ 和 GLTF/GLB 格式的模型
- 应用纹理
- 通过手势控制模型的旋转和缩放
- 调整材质属性（金属度、粗糙度等）

## 两种渲染库的分工

### Three.js 负责：
1. **基础纹理预览**：展示浮雕、光泽等纹理效果
2. **旋转体渲染**：杯子等旋转体产品的渲染
3. **简单 OBJ 模型**：通过 ObjViewer 组件加载和显示

### Babylon.js 负责：
1. **复杂 3D 模型**：加载和渲染更复杂的 3D 模型
2. **高级材质效果**：实现更复杂的材质和光照效果
3. **性能优化**：对于复杂模型的渲染优化

## 使用流程

1. 用户在编辑器中添加纹理效果（如浮雕、光泽）
2. 点击预览按钮，触发 `showTextureView` 状态变更
3. `TexturePreview` 组件被显示，内部使用 `TextureScene` 或 `RotatingBodyScene` 渲染 3D 效果
4. 对于特定产品，可能会使用 `ObjViewer` 或 `BabyLonModelView` 加载特定的 3D 模型

这种设计使得用户可以在 2D 编辑器中直观地预览 3D 效果，提高了设计体验和效率。
# textureManager 与 3dModel 功能对比分析

是的，`textureManager` 和 `3dModel` 目录下的组件都用于显示 3D 效果，但它们有不同的用途和实现方式。

## textureManager 功能分析

`textureManager` 主要用于纹理预览和简单 3D 效果展示，特别是浮雕效果的可视化。

### 核心功能：

1. **纹理浮雕效果预览**：
   - 将灰度图转换为 3D 网格，实现浮雕效果
   - 支持调整浮雕厚度、对比度等参数
   - 主要用于展示纹理效果，如浮雕、光泽等

2. **旋转体渲染**：
   - 专门用于杯子等旋转体产品的渲染
   - 支持创建圆柱体、圆环等几何体

### 实现方式：

`textureScene.ts` 是核心类，使用 Three.js 实现：

```typescript
export default class TextureScene {
  scene?: THREE.Scene;
  private renderer?: THREE.WebGLRenderer;
  private camera?: THREE.PerspectiveCamera;
  // ...

  // 创建普通纹理预览
  create(textureData: any) {
    // 创建3D场景并渲染纹理效果
  }

  // 创建旋转体预览（如杯子）
  createRotating(textureData: any, rotary_params: any) {
    // 创建旋转体3D模型
  }
}
```

## 3dModel 功能分析

`3dModel` 目录下的组件主要用于加载和渲染更复杂的 3D 模型，支持多种格式。

### 核心功能：

1. **复杂 3D 模型加载**：
   - 支持加载 OBJ、GLTF/GLB 等格式的 3D 模型
   - 提供更丰富的交互控制（旋转、缩放等）
   - 适用于展示完整的产品模型

2. **高级材质效果**：
   - 支持 PBR 材质（物理基础渲染）
   - 可调整金属度、粗糙度等材质属性

### 实现方式：

`3dModel` 目录下有两个主要组件：

1. **ObjViewer.tsx**：基于 Three.js 的 React 组件，用于加载 OBJ 和 GLTF 模型：

```typescript
const ObjModel: React.FC<ObjModelProps> = ({ path, texturePath }) => {
  // 加载 OBJ 或 GLTF 模型
  // 支持手势控制（旋转、缩放）
}
```

2. **BabyLonModelView.tsx**：使用 Babylon.js 实现的模型查看器，适用于更复杂的场景。

## 两者的区别与联系

### 区别：

1. **用途不同**：
   - `textureManager`：主要用于纹理效果预览，特别是浮雕效果
   - `3dModel`：用于加载和展示完整的 3D 产品模型

2. **复杂度不同**：
   - `textureManager`：相对简单，专注于纹理效果
   - `3dModel`：更复杂，支持完整的 3D 模型和交互

3. **实现方式不同**：
   - `textureManager`：纯 Three.js 实现，更底层
   - `3dModel`：结合 React 和 Three.js/Babylon.js，更组件化

### 使用场景：

1. **TexturePreview 组件**：使用 `textureManager` 中的 `TextureScene` 类：

```typescript
useEffect(() => {
  textureScene.current = new TextureScene(textureCanvas.current);
  textureScene.current.init();
  // ...
}, []);
```

2. **产品预览**：使用 `3dModel` 中的组件：

```tsx
<ObjModel path="/models/product.obj" texturePath="/textures/product.jpg" />
```

## 总结

1. **textureManager**：
   - 专注于纹理和浮雕效果的 3D 预览
   - 适用于简单的纹理效果展示
   - 主要在 TexturePreview 组件中使用

2. **3dModel**：
   - 用于加载和展示完整的 3D 产品模型
   - 支持更丰富的交互和材质效果
   - 适用于产品展示和预览

两者都是显示 3D 效果的工具，但针对不同的使用场景和需求。在实际应用中，它们可能会结合使用，例如先使用 `textureManager` 预览纹理效果，然后使用 `3dModel` 将纹理应用到完整的产品模型上。
